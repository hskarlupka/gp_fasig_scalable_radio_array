#!/usr/bin/python3.6
"""Script for running a full detector simulation"""

import sys
import argparse
import numpy as np
import gc
import os
from subprocess import check_output, STDOUT
from time import sleep

import pyrex
from pyrex.custom.irex import IREXGrid, IREXClusteredGrid, IREXCoxeterClusters

parser = argparse.ArgumentParser(description=__doc__)
parser.add_argument('energy', type=float,
                    help="""neutrino energy (in GeV)""")
parser.add_argument('detector', type=int,
                    help="""detector selection:
                    01 = 1x1x4 antenna string;
                    02 = 1x1x4x4 antenna clusters;
                    11 = 8x8x2 antenna grid;
                    12 = 20x20x2 antenna grid;
                    21 = 4x4x4x2 antenna clusters;
                    22 = 10x10x4x2 antenna clusters""")
parser.add_argument('-n', '--number', type=int, default=10,
                    help="number of events to generate (default 10)")
parser.add_argument('-t', '--threshold', type=float, default=0.25,
                    help="trigger threshold (in V; default 0.25)")
parser.add_argument('--tot', type=float, default=0,
                    help="trigger time-over-threshold (in ns; default 0)")
parser.add_argument('-e', '--envelope', default="analytic",
                    help="envelope calculation method (default 'analytic')")
parser.add_argument('-a', '--amplification', type=float, default=1e4,
                    help="antenna amplification (default 1e4)")
parser.add_argument('-d', '--dimension', type=float, default=0,
                    help="""x/y size in which to generate neutrinos (default
                         automatically generated by antenna positions)""")
parser.add_argument('--noiseless', action='store_true',
                    help="if present, noise not added to signal")
parser.add_argument('-o', '--output', default="",
                    help="output file name (default stdout)")
parser.add_argument('-g', '--grid_output', default=False,
                    help="grid output file name")


args = parser.parse_args()
args.noisy = not(args.noiseless)


# Set output to either the given file or stdout
if args.output!="":
    f = open(args.output, 'w')
    def flush_file(file):
        file.close()
        f = open(args.output, 'a')
        return f
    def close_file(file):
        file.close()
else:
    f = sys.stdout
    def flush_file(file):
        return file
    def close_file(file):
        pass


# Set energy generation function
if args.energy>=1e3:
    egen = lambda: args.energy
    print("Using fixed neutrino energy {:.2e} GeV".format(args.energy), file=f)
else:
    raise ValueError("Invalid energy")


# Defaults; leave these alone
strings_per_station = 1
string_separation = 100

###############################################################################
####################  Define detector configurations here  ####################
###############################################################################
if args.detector==1:
    print("Using 1x1x4 antenna string", file=f)
    geometry = "grid"
    number_of_stations  = 1
    station_separation  = 500
    antennas_per_string = 4
    antenna_separation  = 20
    lowest_antenna      = -200

elif args.detector==2:
    print("Using, 1x1x4x4 antenna cluster", file=f)
    geometry="clustered"
    number_of_stations  = 1
    station_separation  = 500
    antennas_per_string = 4
    antenna_separation  = 10
    lowest_antenna      = -200
    strings_per_station = 4
    string_separation   = 10

elif args.detector==11:
    print("Using 8x8x2 antenna grid", file=f)
    geometry = "grid"
    number_of_stations  = 8*8
    station_separation  = 500
    antennas_per_string = 2
    antenna_separation  = 40
    lowest_antenna      = -200

elif args.detector==12:
    print("Using 20x20x2 antenna grid", file=f)
    geometry = "grid"
    number_of_stations  = 20*20
    station_separation  = 500
    antennas_per_string = 2
    antenna_separation  = 40
    lowest_antenna      = -200

elif args.detector==13:
    print("Using 8x8x2 antenna wide grid", file=f)
    geometry = "grid"
    number_of_stations  = 8*8
    station_separation  = 1000
    antennas_per_string = 2
    antenna_separation  = 40
    lowest_antenna      = -200

elif args.detector==14:
    print("Using 8x8x2 antenna close grid", file=f)
    geometry = "grid"
    number_of_stations  = 8*8
    station_separation  = 250
    antennas_per_string = 2
    antenna_separation  = 40
    lowest_antenna      = -200

elif args.detector==15:
    print("Using 8x8x2 antenna tight grid", file=f)
    geometry = "grid"
    number_of_stations  = 8*8
    station_separation  = 125
    antennas_per_string = 2
    antenna_separation  = 40
    lowest_antenna      = -200

elif args.detector==21:
    print("Using 4x4x4x2 antenna clusters", file=f)
    geometry="clusters"
    number_of_stations  = 4*4
    station_separation  = 500
    antennas_per_string = 2
    antenna_separation  = 40
    lowest_antenna      = -200
    strings_per_station = 4
    string_separation   = 50

elif args.detector==22:
    print("Using 10x10x4x2 antenna clusters", file=f)
    geometry="clusters"
    number_of_stations  = 10*10
    station_separation  = 500
    antennas_per_string = 2
    antenna_separation  = 40
    lowest_antenna      = -200
    strings_per_station = 4
    string_separation   = 50

elif args.detector==23:
    print("Using 4x4x4x2 antenna wide clusters", file=f)
    geometry="clusters"
    number_of_stations  = 4*4
    station_separation  = 1000
    antennas_per_string = 2
    antenna_separation  = 40
    lowest_antenna      = -200
    strings_per_station = 4
    string_separation   = 50

elif args.detector==31:
    print("Using 4x4x4x2 antenna compact clusters", file=f)
    geometry="clusters"
    number_of_stations  = 4*4
    station_separation  = 500
    antennas_per_string = 2
    antenna_separation  = 40
    lowest_antenna      = -200
    strings_per_station = 4
    string_separation   = 25

elif args.detector==33:
    print("Using 4x4x4x2 antenna wide compact clusters", file=f)
    geometry="clusters"
    number_of_stations  = 4*4
    station_separation  = 1000
    antennas_per_string = 2
    antenna_separation  = 40
    lowest_antenna      = -200
    strings_per_station = 4
    string_separation   = 25

elif args.detector==34:
    print("Using 4x4x4x2 antenna close compact clusters", file=f)
    geometry="clusters"
    number_of_stations  = 4*4
    station_separation  = 250
    antennas_per_string = 2
    antenna_separation  = 40
    lowest_antenna      = -200
    strings_per_station = 4
    string_separation   = 25

elif args.detector==41:
    print("Using 2x4x8x2 antenna clusters", file=f)
    geometry="clusters"
    number_of_stations  = 2*4
    station_separation  = 500
    antennas_per_string = 2
    antenna_separation  = 40
    lowest_antenna      = -200
    strings_per_station = 8
    string_separation   = 50

elif args.detector==43:
    print("Using 2x4x8x2 antenna clusters", file=f)
    geometry="clusters"
    number_of_stations  = 2*4
    station_separation  = 1000
    antennas_per_string = 2
    antenna_separation  = 40
    lowest_antenna      = -200
    strings_per_station = 8
    string_separation   = 50

elif args.detector==44:
    print("Using 2x4x8x2 antenna clusters", file=f)
    geometry="clusters"
    number_of_stations  = 2*4
    station_separation  = 250
    antennas_per_string = 2
    antenna_separation  = 40
    lowest_antenna      = -200
    strings_per_station = 8
    string_separation   = 50

elif args.detector==51:
    print("Using 4x4x4x8 antenna coxeter clusters", file=f)
    geometry="coxeter"
    number_of_stations  = 4*4
    station_separation  = 500
    antennas_per_string = 8
    antenna_separation  = 10
    lowest_antenna      = -95
    strings_per_station = 4
    string_separation   = 25

elif args.detector==52:
    print("Using 10x10x4x8 antenna coxeter clusters", file=f)
    geometry="coxeter"
    number_of_stations  = 10*10
    station_separation  = 500
    antennas_per_string = 8
    antenna_separation  = 10
    lowest_antenna      = -95
    strings_per_station = 4
    string_separation   = 25

elif args.detector==53:
    print("Using 4x4x4x8 antenna wide coxeter clusters", file=f)
    geometry="coxeter"
    number_of_stations  = 4*4
    station_separation  = 1000
    antennas_per_string = 8
    antenna_separation  = 10
    lowest_antenna      = -95
    strings_per_station = 4
    string_separation   = 25

else:
    raise ValueError("Invalid detector option")
###############################################################################
###############################################################################


# Rounding helper function
def rounded(number, factor, direction="closest"):
    if "p" in direction:
        # "up", "pos", or similar
        d = 1
    elif "n" in direction:
        # "down", "neg", or similar
        d = -1
    else:
        d = 0.5
    return factor * int(number/factor + d)

if geometry=="grid":
    det = IREXGrid(number_of_strings=number_of_stations,
                   string_separation=station_separation,
                   antennas_per_string=antennas_per_string,
                   antenna_separation=antenna_separation,
                   lowest_antenna=lowest_antenna)
elif geometry=="clusters":
    det = IREXClusteredGrid(number_of_stations=number_of_stations,
                            station_separation=station_separation,
                            antennas_per_string=antennas_per_string,
                            antenna_separation=antenna_separation,
                            lowest_antenna=lowest_antenna,
                            strings_per_station=strings_per_station,
                            string_separation=string_separation)
elif geometry=="coxeter":
    det = IREXCoxeterClusters(number_of_stations=number_of_stations,
                              station_separation=station_separation,
                              antennas_per_string=antennas_per_string,
                              antenna_separation=antenna_separation,
                              lowest_antenna=lowest_antenna,
                              strings_per_station=strings_per_station,
                              string_separation=string_separation)
else:
    raise ValueError("Geometry '"+geometry+"' not understood")


print(" ", number_of_stations, "station", end="", file=f)
if number_of_stations>1:
    print("s", station_separation, "m apart", file=f)
else:
    print(" only", file=f)

print(" ", antennas_per_string, "antenna", end="", file=f)
if antennas_per_string>1:
    print("s per string", antenna_separation, "m apart starting at",
          lowest_antenna, "m", file=f)
else:
    print(" per string at", lowest_antenna, "m", file=f)

if strings_per_station!=1:
    print(" ", strings_per_station, "strings per station evenly distributed",
          string_separation, "m from station", file=f)

def name_antenna(i, ant):
    antenna = i % antennas_per_string
    string = int(i / antennas_per_string)
    if strings_per_station==1:
        return "st{}_ant{}".format(string, antenna)
    else:
        station = int(string / strings_per_station)
        string = string % strings_per_station
        return "st{}_str{}_ant{}".format(station, string, antenna)

det.build_antennas(trigger_threshold=args.threshold,
                   time_over_threshold=args.tot*1e-9,
                   amplification=args.amplification,
                   noisy=args.noisy, envelope_method=args.envelope,
                   naming_scheme=name_antenna)

print("Antennas have a threshold of", args.threshold, "V", file=f)
if args.tot!=0:
    print("  with a time-over-threshold requirement of", args.tot, "ns", file=f)

print("Antennas have an amplification of", args.amplification, file=f)

if args.noiseless:
    print("No noise will be added to antenna signals", file=f)


if args.dimension<=0:
    if 1e3<=args.energy<1e8:
        extra = 1000
    elif 1e8<=args.energy<1e9:
        extra = 2500
    elif 1e9<=args.energy<1e10:
        extra = 5000
    elif 1e10<=args.energy:
        extra = 10000
    else:
        extra = 10000
    
    max_x = extra + max([np.abs(pos[0]) for pos in det.antenna_positions])
    max_y = extra + max([np.abs(pos[1]) for pos in det.antenna_positions])
    # max_z = extra + max([np.abs(pos[2]) for pos in det.antenna_positions])
    max_z = 2800
    max_x = rounded(max_x, 1000, "up")
    max_y = rounded(max_y, 1000, "up")
    # max_z = rounded(max_z, 1000, "up")
else:
    max_x = args.dimension
    max_y = args.dimension
    max_z = 2800
print("Generating ", args.number, " neutrinos in ",
      round(2*max_x/1000, 1), " x ", round(2*max_y/1000, 1),
      " x ", round(max_z/1000, 1), " km box", sep="", file=f)

f = flush_file(f)

neutrino_generator = pyrex.ShadowGenerator(2*max_x, 2*max_y, max_z, egen)

kernel = pyrex.EventKernel(neutrino_generator, pyrex.IceModel(), det)

# volume_diagonal = pyrex.PathFinder(pyrex.IceModel(),
#                                    from_point=(-max_x, -max_y, -max_z),
#                                    to_point=(max_x, max_y, 0))
# traversal_time = volume_diagonal.time_of_flight(n_steps=1000)
# traversal_time = rounded(traversal_time, 1e-7, "up")
# dt = 0.1e-9
# n_pts = int(traversal_time/dt)+1
# full_times, dt = np.linspace(0, traversal_time, n_pts, retstep=True)
# print(traversal_time*1e6, "microsecond waveforms with dt =", dt, file=f)

triggers = 0
wave_tot = 0
trigger_requirement = min(4, int(len(det)/2))
string_requirement = min(2, strings_per_station*number_of_stations)
print(trigger_requirement, "antenna triggers across", string_requirement,
      "or more strings required for detector trigger\n", file=f)
for i in range(args.number):
    particle = kernel.event()
    triggered = False
    antennas_hit = set()
    strings_hit = set()
    for ant in det:
        if ant.is_hit:
            antennas_hit.add(ant.name)
            strings_hit.add("_".join(ant.name.split("_")[:-1]))
        ant.clear()
    gc.collect()

    if (len(antennas_hit) >= trigger_requirement and
            len(strings_hit) >= string_requirement):
        triggered = True

    print(i, particle.energy, particle.vertex, particle.direction,
          sep="\t", end="\t", file=f)
    if triggered:
        print("triggered", file=f)
        triggers += 1
    else:
        print("missed", file=f)

    if i%100==0:
        f = flush_file(f)

print("\n", triggers, "/", args.number, " events detected", sep="", file=f)

close_file(f)

# GridFTP
if args.grid_output:
    cmd = []
    cmd.append('/cvmfs/icecube.opensciencegrid.org/py2-v2/RHEL_7_x86_64/bin/globus-url-copy')
    cmd.append(args.output)
    cmd.append('gsiftp://gridftp.icecube.wisc.edu' + args.grid_output)
    for i in range(1, 5):
        try:
            output = check_output(cmd, shell=False, env=os.environ, stderr=STDOUT)
            print(output)
            break
        except:
            sleep(30)
